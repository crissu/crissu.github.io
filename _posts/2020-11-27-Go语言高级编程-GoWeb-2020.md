---
layout:     post   				    # 使用的布局（不需要改）
title:      Go语言高级编程-GoWeb 				# 标题 
subtitle:   第五章-GoWeb  #副标题
date:       2020-11-27 				# 时间
author:     Crissu 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 读书笔记
---



### Go语言高级编程—GoWeb：

#### 5.2请求路由：

​		1、大多数Web框架使用的是httprouter

​		2、REST风格

​		3、httprouter使用的数据结构是 压缩动态检索树，检索树的改进版，这个是路由建立、查找的根本技术

​		4、压缩动态检索树的原理和建立过程

​		5、http请求的每一种方法，都是一棵独立的 压缩检索树

#### 5.3中间件

​		1、作用：使用中间件将业务和非业务代码功能解耦；比如在一个请求处理中，增加耗时计算和日志打印等非业务代码，如果不解

​		耦，每个请求处理中，都需要添加相同的代码，这样耦合性太高，不利于维护

​		2、使用中间件剥离非业务代码的原理和逻辑（书P270-271）：主要来说，使用函数适配器来对请求处理的handler进行包装

​		3、把2中的写法，更加优雅的写出来，有点像gin里面的写法

#### 5.4请求校验

​		1、作用：对请求发来的数据进行校验；比如注册账号，密码的长度、邮箱是否正确等验证

​		2、最原始的方法是if else来逐个判断，但是很容易产生“波动拳”这样的代码

​		3、再稍微改善一下的是，使用卫语句（来自《重构》）

​		4、最好是使用请求校验器	validator，利用这个库，可以快速的进行简单的校验，当然也可以自定义错误类型

​		5、请求校验器的原理：

​				1、首先使用struct来存储验证数据，并构建一棵树

​				2、使用反射对结构体进行树的遍历，基于深度搜索的算法

​				tip:

​					1、反射在go语言中的性能不是很好，但是在整个web中，影响整体性能的可能不是反射，具体的话还是要根据pprof来分析

​					2、如果要避免反射，可以使用Parser对源代码进行扫描。。。。

#### 5.5Database和数据库打交道

​		说明：这里将三种方式（database/sql、ORM、SQL Builder），并分析好坏，以及对DB的一些建议

​		1、database/sql：这个是go提供的数据库接口和规范，但是没有提供跟具体数据库实现的协议支持，所以还要引入MySQL驱动

​		2、ORM：

​						1、对象关系映射，是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换，从效果上看，创建了一个可在编程语言里使用的“虚拟对象数据库”。

​						2、ORM的目的是屏蔽数据库层，让数据的操作和存储的具体实现分离

​						3、ORM的问题：这个库会隐式的做一些操作，如果不是很熟悉ORM，可能会出问题；由于隐藏重要的细节，ORM可能是失败的设计。

​		3、SQL Builder：

​						1、相比ORM，这个在SQL和下项目可维护性之间取得了比较好的平衡。

​						2、SQL Builder写起来不麻烦，而且是显示的；

​						3、如果是高并发的OLTP在线系统（On-Line Transaction Processing联机事务处理过程），SQL Builder可能就不合适了。

​		4、脆弱的数据库：

​						1、ORM和SQL Builder都没法在系统上线前做SQL审核

​						2、ORM和SQL Builder提供的功能太灵活，不可能通过测试枚举出所有可能在线上执行的SQL

​						3、如果系统里有类似书P284上的if的话，就难以通过测试用例来cover所有可能的SQL组合了

​						4、从DBA角度出发，还是希望有专门的事前SQL审核机制，并能让其低成本的获取到系统的所有SQL内容，而不是去阅读业务研发人员编写的SQL Builder的相关代码

​						5、上线之前，最好把数据访问对象（DAO）层的变更集的const部分直接拿给DBA来进行审核，就比较方便了



#### 5.6服务流量限制

​		0、前提说明：

​				1、计算机程序的瓶颈分为：磁盘IO瓶颈、CPU计算瓶颈型和网络带宽瓶颈型，分布式有时候外部系统也会导致自身瓶颈。

​				2、如果程序主要是和网络打交道，那瓶颈一定在用户程序而不是操作系统内核

​				3、Go的net库针对不同平台封装了不同的系统调用API，http库又是建立在net库上的，所以我们可以借助标准库，轻松写出高性能的http服务

​				4、可以借助 wrk 来对程序进行基准测试，可以测试QPS（吞吐量）

​				5、有些程序偏网络IO瓶颈：如CDN服务、Proxy服务；有些程序偏CPU\GPU瓶颈：如登录校验服务、图像处理服务；有些程序偏磁盘瓶颈：如专门的存储系统、数据库；具体还是要从压力测试中得出结论。

​				6、不管瓶颈在哪里，要做的事都是一样的——流量限制

​		1、常见的流量限制手段：漏桶和令牌桶，其中令牌桶是允许一定程度的并发的令牌桶在桶中没有令牌时会退化为漏桶

​		2、令牌桶的应用比较广，其原理如下：

​				1、令牌桶模型就是对全局计数的加减法操作过程，但使用计数需要我们自己加读写锁（我们可以用带有缓冲的通道来完成简单的加令牌/取令牌操作）

​				2、当然还可以对1的方法进行改进，类似惰性计算的方式推出桶中的令牌数，不需要利用通道计数	

​		3、服务瓶颈和QoS

​				1、很多瓶颈，可以利用公司的监控系统快速定位，一般时最有效的

​				2、虽然性能指标重要，但对用户提供服务时，还要考虑整体的QoS——服务质量

​				3、QoS包括：可用性、吞吐量、延时、延时变化和丢失等指标

​				4、一般来看，可以通过优化系统，来提高Web服务的CPU利用率，从而提高整个系统的吞吐量

​				5、在线系统的机器，一般都会保持CPU富余的



#### 5.7常见大型Web项目分层

​		1、简单的分为MVC：

​				1、控制器（Controller）：负责转发请求，对请求进行处理

​				2、视图（View）：界面设计人员进行图形界面设计

​				3、模型（Model）：程序员编写程序应有的功能（实现算法等）、数据库专家进行数据管理和数据库设计

​		2、但是现在前后端分离框架比较流行，V这一层已经不需要后端来实现了

​		3、现在比较流行的纯后端API模块一般采用CLD：

​				1、Controller：服务入口，负责处理路由、参数校验、请求转发

​				2、Logic/Service：逻辑（服务）层，一般是业务逻辑的入口，可以认为，从这里开始，所有的请求参数一定是合法的；业务逻辑和业务流程也都在这一层

​				3、DAO/Repository：这一层主要负责和数据、存储打交道；将存储以简单的函数、接口形式给逻辑层使用；负责数据的持久化工作

​		4、在一些使用多通信协议的场景下，如Http和Thrift都要用，则需要在CLD前面加一个协议处理层

​				1、协议处理层：将不同协议的请求数据，处理成统一的数据格式，使得在后面的层里，找不到任何与协议相关的代码

​				2、涉及到中间件，一般是处在协议处理层和Controller层中间；Http中间件可以照常使用，但是Thrift没有和Http对等的中间件来解决非功能性逻辑代码，需要自己写一些较为重复性的代码



#### 5.8接口和表驱动开发

​		0、在Web项目中，经常遇到外部依赖环境的变化，如下方案可以缓解这个问题

​		1、业务系统的发展过程

​				1、平台做大后，会遇到代码膨胀问题，可以将系统中与业务流程本身无关的部分做拆解和异步化，这些需求依赖主流程的数据，但又是旁支，自成体系

​				2、拆解这些非主流系统独立部署、开发和维护后，如果旁支对时延敏感，需使用RPC流程，如果是非实时的系统，可以将数据打包成一条消息，送入消息队列即可

​				3、如果一件事本身变得复杂的话，拆解和异步化就不灵了，需要一定程度的封装抽象

​		2、简单的封装，可以用函数来封装，一步步分解流程

​		3、使用接口来封装

​				1、业务早期，是不适合引入接口的，因为业务流程变动大，过早引入会造成不必要的分层和修改

​				2、当业务流程稳定后，可以使用接口来规范业务的流程，这时候对接口抽象化也容易

​				3、平台可以指定一套统一的业务流程和业务规范，子系统可以引用这个抽象接口，并实现即可

​				4、面向接口编程，不用关心具体的实现；如果对应的业务在迭代中发生了改变，那么所有的逻辑对平台方来说也是完全透明的

​				5、Go的接口还是很友好的，具体看书P301

​		4、表驱动开发，如果函数中有很多if、switch，看起来就比较复杂，可以将调用函数写入map，没错，这个表就是map表；但也有缺点，因为要计算散列，有计算量，在性能敏感的地方需要衡量



#### 5.9灰度发布和A/B测试

​		0、大型系统中容错是非常重要的，但是不可能完全没问题，因此需要灰度发布和A/B测试；也就是，让系统按百分比、分批次到达最终用户也是很重要的

​		1、灰度发布也称金丝雀发布，一般有两种方式实现：

​				1、通过分批次部署实现灰度发布（对系统的旧功能升级迭代时用的比较多）

​				2、通过业务规则进行灰度发布（新功能上线时用的较多）

​		2、通过分批次部署实现灰度发布

​				1、部署的时候，翻倍部署，比如1024台机器，分十次部署，1-2-4-8-16-。。。-512，这样的话出问题了，影响的用户也不多

​		3、通过业务规则进行灰度发布

​				1、常见的，按城市、概率、百分比、白名单、业务线、UA、分发渠道发布

​		4、如何实现一套灰度发布

​				1、业务相关的简单灰度，可以用map来做映射，虽然查询比数组稍慢，但扩展会灵活

​				2、散列，书上测试下来，使用MurmurHash的性能比较好，适合做负载均衡

​				3、对于散列算法，除了性能，还要考虑分布均衡问题

​				4、因此使用散列时，要从性能和均衡两个角度出发考虑

<u></u>